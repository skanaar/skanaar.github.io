<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>nomnoml</title>
<link href='//fonts.googleapis.com/css?family=Dosis:400' rel='stylesheet' type='text/css'>
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<link rel="stylesheet" href="../cluster/css/boilerplate.css">
<link rel="stylesheet" href="../cluster/css/normalize.css">
<link rel="shortcut icon" href="favicon.png">
<link rel="apple-touch-icon" href="img/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="72x72" href="img/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="114x114" href="img/apple-touch-icon-114x114.png">
<style>

html, body {
	height: 100%;
	overflow-x: hidden;
	overflow-y: hidden;
	background: #E5E9EB;
}
.wrap {
	position: relative;
	background: #E5E9EB;
	min-height: 100%;
}
#textarea {
	outline: none;
	position: absolute;
	width: 100%;
	height: 100%;
	background: rgba(0,0,0,0);
	box-sizing: border-box;
	border: 0;
	font-family: Consolas, monospace;
	color: #444;
	padding: 30px;
}
#canvas {
	position: absolute;
	right: 0;
	bottom: 0;
}
a, a:hover, a:active {
	color: #888;
	text-decoration: none
}
a:hover {
	color: #aaa;
}
.tools {
	display: block;
	position: absolute;
	top: 20px;
	right: 40px;
	color: #888;
	text-shadow: 0 1px 0px rgba(255, 255, 255, 0.5);
	font-family: Helvetica, sans-serif;
	font-weight: bold
}
.tools>span {
	font-size: 150%;
}
.tools>a {
	margin-left: 10px;
}
#help {
	display: none;
	position: absolute;
	top: 0px;
	width: 300px;
	background-color: rgba(224,228,230,1);
	border: 0 solid #aaa;
	border-width: 0 0 0 1px;
	color: black;
	font-family: Calibri, Helvetica, sans-serif;
	right:0;
	bottom: 0;
	padding: 60px 10px 0 10px;
}
#help label{
	display: block;
	color: #888;
	margin-top: 1em;
}
#help.visible {
	display: block;
	overflow: auto;
}

</style>
</head>
<body>
	<div class="wrap">

		<canvas id="canvas" width="800" height="800"></canvas>
		<textarea id="textarea" spellcheck="false">[apa]->[banan]
[apa]->[kokos]</textarea>

		<div id="help">
			<label>Car has an Engine</label>
			[Car]-&gt;[Engine]

			<label>Car depends on Fuel</label>
			[Car]--&gt;[Fuel]

			<label>Pickup inherits from Car</label>
			[Pickup]-:&gt;[Car]

			<label>Car implements interface IVehicle</label>
			[Car]--:&gt;[IVehicle]

			<label>Paul and Ron have an association</label>
			[Paul]-[Ron]

			<label>They both depend on each other</label>
			[Chicken]&lt;-&gt;[Egg]

			<label>Car has some attributes</label>
			[Car]:[Car|maxSpeed: Float;color: Color|]

			<label>Engine has an operation</label>
			[Engine]:[Engine||start()]

			<label>Set font</label>
			#font: Times

			<label>Layout the diagram really tight</label>
			#fontSize: 8<br>
			#spacing: 11

			<label>Set left-to-right layout ('down' is default)</label>
			#direction: right
		</div>

		<div class="tools">
			<span>nomnoml &nbsp;&nbsp;</span>
			<a href="javascript:discardCurrentGraph()">
				<i class="fa fa-fw fa-trash-o fa-lg"></i>
			</a>
			<a id="savebutton" href="javascript:void(0)" download="uml.png">
				<i class="fa fa-fw fa-camera fa-lg"></i>
			</a>
			<a href="javascript:void(0)" onclick="toggleHelp()">
				<i class="fa fa-fw fa-book fa-lg"></i>
			</a>
		</div>
	</div>

	<script src="//code.jquery.com/jquery-2.1.0.min.js"></script>
	<script src="underscore.js"></script>
	<script src="dagre.min.js"></script>
	<script src="../cluster/js/canvas.js"></script>
	<script src="../cluster/js/vector.js"></script>
	<script type="text/vnd.nomnoml.class" id="defaultGraph">#fontSize: 14

[pirate]:[pirate | eyeCount: Int | raid();pillage()]
[jollyness]:[jollyness | magnitude: Real |]

[marauder]<:-[pirate]
[pirate]-[mischief]
[jollyness]->[pirate]
[jollyness]->[rum]
[jollyness]->[singing]
[pirate]->[rum|tastiness: Int|swig()]
[pirate]->[singing]
[singing]<->[rum]</script>
	<script>

	(function (){
		var link = document.getElementById('savebutton')
		link.addEventListener('click', downloadImage, false);
		function downloadImage(){
			var url = canvas.toDataURL('image/png')
			var downloadUrl = url.replace(/^data:image\/[^;]/, 'data:application/octet-stream')
		    link.href = downloadUrl;
		}
	}())

	function toggleHelp(){
		document.getElementById('help').classList.toggle("visible");
	}

	function fillScreen(){
		w = canvas.parentElement.offsetWidth
		h = canvas.parentElement.offsetHeight
		canvas.setAttribute('width', w*0.75)
		canvas.setAttribute('height', h-200)
		sourceChanged()
	}

	var w, h;
	var canvas = document.getElementById('canvas')
	var textarea = document.getElementById('textarea')
	var g = skanaar.Canvas(canvas, {})
	window.addEventListener('resize', _.throttle(fillScreen, 750, {leading: true}))
	textarea.addEventListener('input', _.debounce(sourceChanged, 300))
	textarea.value = localStorage.getItem('nomnoml.lastSource') || document.getElementById('defaultGraph').innerHTML
	fillScreen()

	function discardCurrentGraph(){
		textarea.value = document.getElementById('defaultGraph').innerHTML
		sourceChanged()
	}

	function setFont(ast, isBold){
		var style = isBold === 'bold' ? 'bold ' : ''
		g.ctx.font = style+ast.fontSize+'pt '+ast.font+', Helvetica, sans-serif'
	}

	function sourceChanged(){
		var ast = parse(textarea.value)
		setFont(ast, 'bold')
		localStorage.setItem('nomnoml.lastSource', textarea.value)
		render(ast, layout(ast, measureNode))
	}

	function measureNode(fontSize, node){
		var lines = _.flatten([node.name, node.attrs, node.ops])
		var widths = _.map(lines, function (n){ return g.ctx.measureText(n).width })
		return {
			width: _.max(widths) + 25,
			height: (fontSize) *  (lines.length + (lines.length===1 ? 1.5 : 2.5))
		}
	}

	function trim(s){ return s.trim() }
	function trims(ss){ return _.map(ss, trim) }

	function parse(source){
		function parseRelationString(s){
			var pattern = /\[(.*)\]\s*(-:>|<:-|--:>|<:--|->|<-|-->|<--|<->|-|--|:)\s*\[(.*)\]/
			var parts = s.match(pattern)
			return parts && trims(_.tail(parts))
		}
		function parseMetaString(s){
			var pattern = /#([^:]*):(.*)/
			var parts = s.match(pattern)
			return parts && trims(_.tail(parts))
		}
		var lines = source.split('\n')
		var bimap = _.compact(_.map(lines, parseRelationString))
		var directives = _.object(_.compact(_.map(lines, parseMetaString)))
		var nodes = {}
		var relations = []
		function parseClass(nodes, classSerialization){
			var tokens = trims(classSerialization.split('|'))
			if (tokens.length === 3)
				delete nodes[tokens[0]]
			return nodes[tokens[0]] || {
				name: tokens[0],
				attrs: tokens[1] ? tokens[1].split(';') : [],
				ops: tokens[2] ? tokens[2].split(';') : []
			}
		}
		_.each(bimap, function (pair){
			var left = parseClass(nodes, pair[0])
			var right = parseClass(nodes, pair[2])
			if (left.name) nodes[left.name] = left
			if (right.name) nodes[right.name] = right
			var isLeftToRight = pair[1][0] === '-'
			var a = isLeftToRight ? left : right
			var b = isLeftToRight ? right : left
			var t = {
				'-:>': 'generalization',
				'<:-': 'generalization',
				'--:>': 'realization',
				'<:--': 'realization',
				'-->': 'dependency',
				'<--': 'dependency',
				'->': 'association',
				'<-': 'association',
				'<->': 'twoway',
				'-': 'nondirectional',
				'--': 'note'
			}[pair[1]]
			if (t && a.name && b.name)
				relations.push({start: a.name, end:b.name, type: t})
		})

		return {
			nodes: nodes,
			relations: relations,
			fontSize: (+directives.fontSize) || 12,
			font: directives.font || 'Calibri',
			spacing: (+directives.spacing) || 30,
			direction: {down: 'TB', right: 'LR'}[directives.direction] || 'TB',
			fillArrows: directives.fillArrows === 'true',
			frame: directives.frame
		}
	}

	function layout(ast, measureNode){
		function buildDagreGraph(ast){
			var g = new dagre.Digraph()
			_.each(ast.nodes, function (e, key){
				var size = measureNode(ast.fontSize, e)
				g.addNode(key, { label: key, width: size.width, height: size.height })
			})
			_.each(ast.relations, function (r){
				g.addEdge(null, r.start, r.end)
			})
			return g
		}
		function packageDagreGraph(ast, dagreLayout){
			var nodes = {}
			var relations = []
			dagreLayout.eachNode(function (key, data){
				nodes[key] = {
					name: key,
					x: data.x,
					y: data.y,
					attrs: ast.nodes[key].attrs,
					ops: ast.nodes[key].ops,
					width: data.width,
					height: data.height
				}
			})
			dagreLayout.eachEdge(function (id, start, end, data){
				relations.push({
					start: nodes[start],
					middle: _.pick(data, 'x', 'y'),
					end: nodes[end],
					path: _.flatten([nodes[start], data.points, nodes[end]]),
					type: _.findWhere(ast.relations, {start: start, end: end}).type
				})
			})
			var g = dagreLayout.graph()
			return { nodes: nodes, relations: relations, width: g.width, height: g.height }
		}
		var dagreLayout = dagre.layout()
							   .rankSep(ast.spacing)
							   .nodeSep(ast.spacing)
							   .edgeSep(ast.spacing)
							   .rankDir(ast.direction)
							   .run(buildDagreGraph(ast))
		return packageDagreGraph(ast, dagreLayout)
	}

	function render(ast, layout){

		function rectIntersection(p1, p2, w, h){
			var v = diff(p1, p2)
			for(var t=1; t>=0; t-= 0.01){
				var p = mult(v, t)
				if(Math.abs(p.x) < w/2 && Math.abs(p.y) < h/2)
					return add(p2, p)
			}
			return p1
		}

		function drawArrow(path, isOpen, target){
			var size = ast.spacing / 30
			var v = diff(path[path.length-2], _.last(path))
			var nv = normalize(v)
			var arrowPoint = rectIntersection(path[path.length-2], _.last(path), target.width, target.height)
			var arrowBase = add(arrowPoint, mult(nv, 10*size))
			var t = rot(nv)
			var arrow = [
				add(arrowBase, mult(t, 4*size)),
				(isOpen && !ast.fillArrows) ? add(arrowPoint, mult(nv, 5*size)) : arrowBase,
				add(arrowBase, mult(t, -4*size)),
				arrowPoint,
				add(arrowBase, mult(t, 4*size))
			]
			g.ctx.fillStyle = isOpen ? '#111' : '#fff'
			var ctx = g.path(arrow).fill().stroke()
		}

		function drawFrame(title, layout){
			g.ctx.fillStyle = '#000'
			setFont(ast, 'normal')
			g.ctx.textAlign = 'left'
			g.ctx.strokeRect(0.5, 0.5, layout.width+2*frameMarg, layout.height+frameMarg*3+lineHeight)
			var w = g.ctx.measureText(title).width + frameMarg
			var h = lineHeight+frameMarg
			g.path([{x:0, y:h}, {x:w-frameMarg*2/3, y:h}, {x:w, y:h-frameMarg}, {x:w, y:0}]).stroke()
			g.ctx.fillText(ast.frame, frameMarg/2, frameMarg/2 + lineHeight)
		}

		function rnd(x){ return Math.round(x) }

		var empty = !true
		var filled = !false
		var lineHeight = ast.fontSize
		var frameMarg = 10

		g.ctx.save()
		g.ctx.clearRect(0, 0, w, h)
		g.ctx.strokeStyle = '#111'
		g.ctx.lineWidth = 1

		g.ctx.translate(rnd((g.width() - layout.width)/2)+0.5, 0.5)

		if (ast.frame)
			drawFrame(ast.frame, layout)

		g.ctx.translate(frameMarg, frameMarg*2 + lineHeight)
		g.ctx.textAlign = 'center'

		_.each(layout.relations, function (r){
			if (r.type == 'generalization'){
				g.path(r.path).stroke()
				drawArrow(r.path, empty, r.end)
			}
			else if (r.type == 'realization'){
				g.dashPath(r.path, 3, 3)
				drawArrow(r.path, empty, r.end)
			}
			else if (r.type == 'dependency'){
				g.dashPath(r.path, 3, 3)
				drawArrow(r.path, filled, r.end)
			}
			else if (r.type == 'association'){
				g.path(r.path).stroke()
				drawArrow(r.path, filled, r.end)
			}
			else if (r.type == 'nondirectional'){
				g.path(r.path).stroke()
			}
			else if (r.type == 'note'){
				g.dashPath(r.path, 3, 3)
			}
			else if (r.type === 'twoway'){
				g.path(r.path).stroke()
				drawArrow(r.path, 'dependency', r.end)
				drawArrow(_.clone(r.path).reverse(), 'dependency', r.start)
			}
		})
		g.ctx.lineWidth = 1
		_.each(layout.nodes, function (e){
			var w = e.width
			var h = e.height
			var rx = rnd(e.x-w/2)
			var ry = rnd(e.y-h/2)
			var y = e.y-h/2
			g.ctx.fillStyle = 'rgba(220, 220, 220, 1)'
			g.ctx.fillRect(rx, ry, w, h)
			g.ctx.strokeRect(rx, ry, w, h)
			g.ctx.fillStyle = '#333'
			y += rnd(lineHeight*1.5)
			setFont(ast, 'bold')
			g.ctx.textAlign = 'center'
			if (!(e.attrs.length || e.ops.length)){
				g.ctx.fillText(e.name, e.x, y+ast.fontSize/5)
			} else {
				g.ctx.fillText(e.name, e.x, y)
				y += rnd(lineHeight/2)
				var line = [{x: rx, y: y}, {x: rx+w, y: y}]
				g.path(line).stroke()
				g.path(line, {x:0, y:rnd((e.attrs.length+0.75)*lineHeight)}).stroke()
				y += lineHeight/4
			}
			setFont(ast, 'normal')
			g.ctx.textAlign = 'left'
			var tx = rnd(e.x-w/2)+13
			_.each(e.attrs, function (a, i){
				y += lineHeight
				g.ctx.fillText(a, tx, y)
			})
			y += lineHeight*0.75
			_.each(e.ops, function (a, i){
				y += lineHeight
				g.ctx.fillText(a, tx, y)
			})
		})
		g.ctx.restore()
	}

	</script>
</body>
</html>