<surfaces-viewer>

  <div class="list">
    <div each={e in world.surfaces} onclick={edit} class={ list_item: true, active: e==selected }>
      {e.id}
    </div>
    <div><button onclick={add}>+ New Surface</button></div>
  </div>

  <svg width=800 height=500 class="surface-mesh">
    <path
      each={e in mesh}
      d="M{e.a.x},{e.a.y} L{e.b.x},{e.b.y} L{e.c.x},{e.c.y} L{e.d.x},{e.d.y} Z"
      fill="#{e.fill}"/>
  </svg>

  <div class="sidebar" show={!!selected}>

    <div class="input-grid">
      <em>id</em> <input type=text ref="idField" value={selected && selected.id}><br/>
      <em>desc</em> <input type=text ref="descField" value={selected && selected.desc}><br/>
      <em>zoom</em> <input type=number ref="zoomField" value={selected && selected.zoom}><br/>
      <em>height</em> <input type=number ref="heightField" value={selected && selected.height}><br/>
      <em>octaves</em> <input type=number ref="octavesField" value={selected && selected.octaves}><br/>
      <em>falloff</em> <input type=number ref="falloffField" value={selected && selected.falloff}><br/>
      <em>curve</em> <input type=text ref="curveField" value={selected && selected.curve.join()}><br/>
      <em>spectrum</em> <input type=text ref="spectrumField" value={selected && selected.spectrum.join()}><br/>
    </div>

    <br/>
    <button onclick={remove}>Delete</button>
    <button onclick={save}>Save</button>
    <button onclick={cancelEditing}>Cancel</button>
  </div>

  <style>
    .surface-mesh {
      display: block;
      margin: 50px auto;
    }
  </style>

  <script>
    var self = this

    self.world = { surfaces: [] }
    self.selected = null

    self.add = function () {
      self.world.surfaces.push({
        id: "unnamed",
        desc: "",
        zoom: 1,
        height: 3,
        octaves: 3,
        falloff: 0.5,
        curve: [0, 1],
        spectrum: ["06F", "F00"]
      })
    }

    self.remove = function () {
      self.world.surfaces = self.world.surfaces.filter(e => e != self.selected)
    }
    
    self.edit = function (e) {
      self.selected = e.item.e
      drawTerrain(self.selected)
    }
    
    self.save = function (e) {
      self.selected.id = self.refs.idField.value
      self.selected.desc = self.refs.descField.value
      self.selected.zoom = self.refs.zoomField.value
      self.selected.height = self.refs.heightField.value
      self.selected.octaves = self.refs.octavesField.value
      self.selected.falloff = self.refs.falloffField.value
      self.selected.curve = self.refs.curveField.value.split(',').map(x => +x)
      self.selected.spectrum = self.refs.spectrumField.value.split(',')
      drawTerrain(self.selected)
    }

    self.cancelEditing = function () {
      self.selected = null
      self.update()
    }

    function loadWorld() {
        self.world = getWorld()
        self.update()
    }

    self.on('mount', function() {
      window.events.on('world-updated', loadWorld)
      window.events.on('save-world', () => saveWorld(self.world))
      loadWorld()
    })

    function toHex(x){ return constrain(0, 16, Math.round(x)).toString(16) }

    function colorLerp(c1, c2, factor){
      return [
        toHex(lerp([parseInt(c1[0], 16), parseInt(c2[0], 16)], factor)),
        toHex(lerp([parseInt(c1[1], 16), parseInt(c2[1], 16)], factor)),
        toHex(lerp([parseInt(c1[2], 16), parseInt(c2[2], 16)], factor))
      ].join('')
    }

    function sq(x){ return x*x }

    function constrain(min, max, x) { return Math.min(max, Math.max(min, x)) }

    function lerp(values, x) {
      var a = constrain(0, 0.999, x)
      var k = (a*(values.length-1)) % 1
      var i = Math.floor(a*(values.length-1))
      var c1 = values[i]
      var c2 = values[i+1]
      return c1*(1-k) + c2*k
    }

    function spectrumSample(spectrum, x){
      return _.map([
        lerp(_.map(spectrum, x => parseInt(x[0],16)), x),
        lerp(_.map(spectrum, x => parseInt(x[1],16)), x),
        lerp(_.map(spectrum, x => parseInt(x[2],16)), x)
      ], toHex).join('')
    }

    function drawTerrain(style){
      var center = Vec(400, 250)
      var radius = 348
      var angle = 0.3
      var res = 16
      var shadow = '000'

      var noise = Noise({ persistence: style.falloff, octaves: style.octaves, zoom: 0.2 })

      function terrainPoint(i, j, h){
        var p = rotate(mult(Vec(i-res, j-res), radius/res), angle)
        return Vec(p.x, p.y/2 - h * style.height*40/style.zoom)
      }

      var terrain = []
      for(var i=0; i<2*res+1; i++){
        terrain.push([])
        for(var j=0; j<2*res+1; j++){
          terrain[i][j] = noise(Vec(i*style.zoom/res, j*style.zoom/res))
          terrain[i][j] = lerp(style.curve, terrain[i][j])
        }
      }

      self.mesh = []

      for(var i=0; i<2*res; i++){
        for(var j=0; j<2*res; j++){
          if (sq(i-res) + sq(j-res) > sq(res)) continue
          var sunAngle = 0.75 + (terrain[i][j]-terrain[i+1][j])*res/15
          var color = colorLerp(shadow, spectrumSample(style.spectrum, terrain[i][j]), sunAngle)
          var alpha = constrain(0, 1, 0.6*(res - mag(Vec(i-res+1, j-res+1))))
          self.mesh.push({
            a: add(center, terrainPoint(i+0, j+0, terrain[i+0][j+0]-0.3)),
            b: add(center, terrainPoint(i+1, j+0, terrain[i+1][j+0]-0.3)),
            c: add(center, terrainPoint(i+1, j+1, terrain[i+1][j+1]-0.3)),
            d: add(center, terrainPoint(i+0, j+1, terrain[i+0][j+1]-0.3)),
            fill: color
          })
        }
      }
    }

    function Noise(conf) {
      var res = 256
      var persistence = conf.persistence || 0.5
      var octaves = conf.octaves || 1
      var scale = conf.zoom * 2 || 2
      var matrix = _.range(res).map(e => Math.random() - 0.5)

      function smoothstep(x) { return x*x*(3 - 2*x) }

      function lerp(factor, a, b) { return a + (b-a)*factor }
      
      function getSingleOctave(p) {
        var x0 = Math.floor(p.x)
        var y0 = Math.floor(p.y)
        var x1 = x0+1
        var y1 = y0+1
        var ux = smoothstep(p.x - x0)
        var uy = smoothstep(p.y - y0)
        var yy0 = lerp(uy, val(x0, y0), val(x0, y1))
        var yy1 = lerp(uy, val(x1, y0), val(x1, y1))
        return lerp(ux, yy0, yy1)
      }
      
      function val(x, y) {
        return matrix[Math.abs(1024 + x + 7*y) % matrix.length]
      }

      return function (p) {
        var sum = 0.0
        var pos = mult(p, 1/scale)
        var amp = 1.0
        for (var i=0; i<octaves; i++) {
          sum = sum + amp * getSingleOctave(pos)
          pos = mult(pos, 2)
          amp = amp * persistence
        }
        return sum + 0.5
      }
    }

  </script>

</surfaces-viewer>
