<models-viewer>

  <div class="list">
    <div each={model in world.models} onclick={edit} class={ list_item: true, active: model==selected }>
      {model.name}
    </div>
    <div><button onclick={add}>+ New Model</button></div>
  </div>

  <svg width=800 height=800 class="canvas-3d">
    <path
      each={e in mesh}
      riot-d="M{e[0][0]},{e[0][1]} L{e[1][0]},{e[1][1]} L{e[2][0]},{e[2][1]} L{e[3][0]},{e[3][1]} Z"
      fill={shading(e)} stroke="#000"/>
  </svg>

  <div class="toolbox">
    <div class="btn-group">
      <a onclick={setCamera.bind(null, 'top')} class="toggle-btn {(camera == 'top') && 'active'}">Top
      </a><a onclick={setCamera.bind(null, 'front')} class="toggle-btn {(camera == 'front') && 'active'}">Front
      </a><a onclick={setCamera.bind(null, 'side')} class="toggle-btn {(camera == 'side') && 'active'}">Side
      </a><a onclick={setCamera.bind(null, 'perspective')} class="toggle-btn {(camera == 'perspective') && 'active'}">Perspective</a>
    </div>
  </div>

  <div class="sidebar" show={!!selected}>
    <input type=text ref="nameField" value={selected && selected.name}>
    <div class="input-grid">
      <em>name</em> <input type=number ref="resField" value={selected && selected.res}><br/>
    </div>

    <label>Transform Stack</label>
    <textarea value={asJson(selected && selected.transform)} ref="transformField"></textarea>

    <label>Path</label>
    <textarea value={asJson(selected && selected.path)} ref="pathField"></textarea>

    <br/>
    <button onclick={remove}>Delete</button>
    <button onclick={endEditing}>Done</button>
    <button onclick={cancelEditing}>Cancel</button>
  </div>

  <style>
    .sidebar textarea {
      width: 170px;
      height: 140px;
    }
    .canvas-3d {
      display: block;
      margin: 0 auto;
    }
  </style>

  <script>
    var self = this
    self.camera = 'perspective' // top | front | side |Â perspective
    self.world = { models: [
      { "name": "xyz", "geometry": "lathe", "res": 8,
        "transform": [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 0, 0, 0]],
        "path": [[1,0,-100], [200,0,0], [100,0,100]]
      }
    ] }
    self.mesh = []

    self.setCamera = function (mode) {
      self.camera = mode
      updateMesh()
    }

    self.asJson = function (data) {
      return _.stringify(data, { maxLength: 40 })
    }

    self.add = function () {
      self.world.models.push({
        name: "xyz",
        geometry: "lathe",
        res: 8,
        transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 0, 0, 0]],
        path: [[1,0,-100], [200,0,0], [100,0,100]]
      })
    }
    
    self.edit = function (e) {
      self.selected = e.item.model
      updateMesh()
    }
    
    self.endEditing = function (e) {
      self.selected.name = self.refs.nameField.value
      self.selected.res = +self.refs.resField.value
      self.selected.transform = JSON.parse(self.refs.transformField.value)
      self.selected.path = JSON.parse(self.refs.pathField.value)
      updateMesh()
      self.update()
    }

    self.cancelEditing = function () {
      self.selected = null
      self.update()
    }

    self.shading = function (quad) {
      var normal = vnormalize(vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3])))
      var shade = Math.ceil(128*vdot(normal, [1,-1,-1]))
      if (shade < 0) shade = 0
      return 'rgba('+[shade,shade,shade].join()+',0.75)'
    }

    function updateMesh(){
      self.mesh = applyPerspective(applyTransformations(lathe(self.selected), self.selected))
      self.mesh = self.mesh.filter(function (quad) {
        let normal = vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3]))
        return normal[2] < 0
      })
      self.mesh = _.sortBy(self.mesh, quad => -(quad[0][2]+quad[2][2]))
    }

    function lathe(model) {
      var mesh = []
      _.range(0, model.res).map(function (slice) {
        var vertex = (i,j) => mapply(rotateZ(Math.PI*2 * i/model.res), model.path[j])
        for (var i=1; i<model.path.length; i++) {
          mesh.push([vertex(slice,i), vertex(slice+1,i), vertex(slice+1,i-1), vertex(slice,i-1)])
        }
      })
      return mesh
    }

    function transformQuad(quad, matrix) {
      return quad.map(p => mapply(matrix, p))
    }

    function transformMesh(mesh, m) {
      if (m[0] == 'scale')
        return mesh.map(quad => transformQuad(quad, scale(m[1], m[2], m[3])))
      if (m[0] == 'rotate')
        return mesh.map(quad => transformQuad(quad, rotateXYZ(m[1], m[2], m[3])))
      if (m[0] == 'translate')
        return mesh.map(quad => quad.map(p => [p[0]+m[1], p[1]+m[2], p[2]+m[3]]))
    }

    function applyTransformations(mesh, model) {
      return model.transform.reduce((mesh, trans) => transformMesh(mesh, trans), mesh)
    }

    function applyPerspective(mesh) {
      var zoom = scale(2,2,2)
      var perspective = {
        top: mmult(zoom, rotateX(Math.PI)),
        front: mmult(zoom, rotateX(Math.PI/2)),
        side: mmult(zoom, rotateY(Math.PI/2)),
        perspective: mmult(zoom, mmult(rotateZ(Math.PI+0.75), rotateX(Math.PI-1.1)))
      }[self.camera] || mmult(rotateZ(0.3), rotateX(1.21))
      return mesh.map(q => transformQuad(q, perspective).map(p => vtranslate(p, [400,400,0])))
    }

    function loadWorld() {
        self.world = getWorld()
        self.update()
    }

    self.on('mount', function() {
      window.events.on('world-updated', loadWorld)
      window.events.on('save-world', () => saveWorld(self.world))
      loadWorld()
    })

    var rotateX = (a) => [1,0,0,  0,Math.cos(a),-Math.sin(a),  0,Math.sin(a),Math.cos(a)]
    var rotateY = (a) => [Math.cos(a),0,Math.sin(a), 0,1,0, -Math.sin(a),0,Math.cos(a)]
    var rotateZ = (a) => [Math.cos(a),-Math.sin(a),0,  Math.sin(a),Math.cos(a),0,  0,0,1]
    var rotateXYZ = (x,y,z) => mmult(mmult(rotateX(x), rotateY(y)), rotateZ(z))
    var scale = (x,y,z) => [x,0,0,  0,y,0,  0,0,z]
    var identity = () => [1,0,0, 0,1,0, 0,0,1]
    var vtranslate = (vec, delta) => [vec[0]+delta[0], vec[1]+delta[1], vec[2]+delta[2]]
    var vdiff = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]]
    var vdot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
    var vnormalize = v => {
      var mag = Math.sqrt(vdot(v, v))
      return [v[0]/mag, v[1]/mag, v[2]/mag]
    }
    var vcross = (a, b) => [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]

    function mapply (matrix, vec) {
        return [vec[0]*matrix[0+3*0] + vec[1]*matrix[1+3*0] + vec[2]*matrix[2+3*0],
                vec[0]*matrix[0+3*1] + vec[1]*matrix[1+3*1] + vec[2]*matrix[2+3*1],
                vec[0]*matrix[0+3*2] + vec[1]*matrix[1+3*2] + vec[2]*matrix[2+3*2]]
    }

    function mmult (a, b) {
        var m = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        for (var i=0; i<3; i++) {
            for (var j=0; j<3; j++) {
                for (var k=0; k<3; k++) {
                    m[i+3*j] += a[i+3*k]*b[k+3*j]
                }
            }
        }
        return m
    }

  </script>

</models-viewer>
