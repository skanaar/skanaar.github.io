<models-viewer>

  <svg width=1000 height=800 class="canvas-3d">
    <path
      each={e in box}
      riot-d="M{e[0][0]},{e[0][1]} L{e[1][0]},{e[1][1]} L{e[2][0]},{e[2][1]} L{e[3][0]},{e[3][1]} Z"
      fill=none stroke="#000"/>
    <path
      each={e in mesh}
      riot-d="M{e[0][0]},{e[0][1]} L{e[1][0]},{e[1][1]} L{e[2][0]},{e[2][1]} L{e[3][0]},{e[3][1]} Z"
      fill={shading(e)} stroke="#000"/>
  </svg>

  <div class="list">
    <div class="tools">
      <div class="btn-group">
        <a each={e in allTags()} onclick={setFilter(e)} class="toggle-btn {(filter == e) && 'active'}">{e}</a>
      </div>
    </div>
    <div each={model in filteredModels()} onclick={edit} class={ list_item: true, active: model==selected }>
      {model.name}
    </div>
  </div>

  <div class="toolbox">
    <button onclick={addComposition}>+ New Model</button>
    <div class="btn-group">
      <a onclick={setCamera.bind(null, 'top')} class="toggle-btn {(camera == 'top') && 'active'}">Top
      </a><a onclick={setCamera.bind(null, 'front')} class="toggle-btn {(camera == 'front') && 'active'}">Front
      </a><a onclick={setCamera.bind(null, 'side')} class="toggle-btn {(camera == 'side') && 'active'}">Side
      </a><a onclick={setCamera.bind(null, 'perspective')} class="toggle-btn {(camera == 'perspective') && 'active'}">Perspective</a>
    </div>
    <div class="btn-group">
      <a class="toggle-btn" onclick={up}>Up in list</a><a class="toggle-btn" onclick={down}>Down in list</a>
    </div>
  </div>

  <div class="sidebar" show={!!selected}>
    <label>Source</label>
    <textarea value={asJson(selected)} ref="sourceField"></textarea>

    <label></label>
    <button onclick={compile}>Compile Mesh</button>
    <button onclick={remove}>Delete</button><br/>
    <button onclick={endEditing}>Done</button>
    <button onclick={cancelEditing}>Cancel</button>
  </div>

  <style>
    .sidebar textarea {
      width: 230px;
      height: 80%;
    }
    .canvas-3d {
      display: block;
      margin: 0 auto;
    }
  </style>

  <script>
    var self = this
    var app = self.opts.app || window.app
    self.camera = 'perspective' // top | front | side |Â perspective
    self.world = { models: [] }
    self.mesh = []
    self.box = []
    self.filter = ''
    self.allTags = () => app.allTags(self.world.models).filter(e => e)
    self.filteredModels = () => app.tagFilter(self.world.models, self.filter)

    self.setFilter = function (type) {
      return () => self.filter = (self.filter == type ? null : type)
    }

    self.setCamera = function (mode) {
      self.camera = mode
      updateMesh()
    }

    self.asJson = function (data) {
      return _.stringify(data, { maxLength: 50, indent: 1 })
    }

    self.addComposition = function () {
      self.world.models.unshift({
        name: "unnamed",
        geometry: "composite",
        transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 0, 0, 0]],
        parts: [
          {
            geometry: "lathe",
            res: 4,
            transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 50, 0, 0]],
            path: [[0,0,-50], [50,0,0], [0,0,50]]
          }
        ]
      })
      self.selected = self.world.models[0]
      updateMesh()
    }

    self.up = function () {
      _.bubbleUp(self.world.models, self.world.models.findIndex(e => e == self.selected))
    }

    self.down = function () {
      _.bubbleDown(self.world.models, self.world.models.findIndex(e => e == self.selected))
    }
    
    self.edit = function (e) {
      self.selected = e.item.model
      updateMesh()
    }

    function clearObject(e) {
      Object.keys(e).forEach(key => delete e[key])
    }
    
    self.endEditing = function (e) {
      clearObject(self.selected)
      _.extend(self.selected, JSON.parse(self.refs.sourceField.value))
      updateMesh()
      self.update()
    }

    self.cancelEditing = function () {
      self.selected = null
      self.update()
    }

    self.compile = function () {
      var compilate = {
        name: 'Compiled ' + self.selected.name,
        geometry: 'mesh',
        transform: [['scale', 1, 1, 1], ['rotate', 0, 0, 0], ['translate', 0, 0, 0]],
        quads: buildMesh(self.selected).map(q => q.map(p => p.map(x => Math.round(x))))
      }
      self.world.models.push(compilate)
      self.selected = compilate
    }

    self.remove = function () {
      if (!confirm('Remove model ' + self.selected.name)) return
      self.world.models = self.world.models.filter(e => e != self.selected)
      self.selected = null
    }

    self.shading = function (quad) {
      var normal = vnormalize(vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3])))
      var shade = Math.ceil(200*vdot(normal, vnormalize([1,-1,-1])))
      if (shade < 0) shade = 0
      return 'rgba('+[shade,shade,shade].join()+',0.85)'
    }

    function buildMesh(model){
      switch(model.geometry) {
      case 'lathe': return applyTransforms(lathe(model), model)
      case 'composite': return applyTransforms(_.flatten(model.parts.map(buildMesh), true), model)
      case 'sphere': return applyTransforms(sphere(model), model)
      case 'mesh': return applyTransforms(model.quads, model)
      }
    }

    function updateMesh(){
      self.mesh = applyPerspective(buildMesh(self.selected))
      self.mesh = self.mesh.filter(function (quad) {
        let normal = vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3]))
        return normal[2] < 0
      })
      self.mesh = _.sortBy(self.mesh, quad => -(quad[0][2]+quad[2][2]))
      self.box = applyPerspective([[[-200,-200,0], [-200,200,0], [200,200,0], [200,-200,0]]])
    }

    function lathe(model) {
      var mesh = []
      var maxAngle = model.angle || Math.PI*2
      _.range(0, model.res).map(function (slice) {
        var vertex = (i,j) => mapply(rotateZ(maxAngle * i/model.res), model.path[j])
        for (var i=1; i<model.path.length; i++) {
          mesh.push([vertex(slice,i), vertex(slice+1,i), vertex(slice+1,i-1), vertex(slice,i-1)])
        }
      })
      return mesh
    }

    function transformQuad(quad, matrix) {
      return quad.map(p => mapply(matrix, p))
    }

    function parabola(p, vec) {
      var dir = vnormalize(vec)
      var lift = vdot(dir, p)
      var p2 = vadd(vmult(-lift, dir), p)
      return vadd(p, vmult(_.sq(vmag(p2)), vec))
    }

    function lerp(k, a, b) { return (1-k)*a + k*b }

    function radialWave(p, args) {
      let radius = lerp(args[1], 0.5 + 0.5 * Math.sin(args[0] * Math.atan2(p[1], p[0])), 1)
      return [p[0]*radius, p[1]*radius, p[2]]
    }

    function transformMesh(mesh, m) {
      if (m[0] == 'scale')
        return mesh.map(quad => transformQuad(quad, scale(m[1], m[2], m[3])))
      if (m[0] == 'rotate')
        return mesh.map(quad => transformQuad(quad, rotateXYZ(m[1], m[2], m[3])))
      if (m[0] == 'translate')
        return mesh.map(quad => quad.map(p => [p[0]+m[1], p[1]+m[2], p[2]+m[3]]))
      if (m[0] == 'parabola'){
        var vec = [m[1], m[2], m[3]]
        return mesh.map(quad => quad.map(p => parabola(p, vec)))
      }
      if (m[0] == 'radial-wave'){
        var vec = [m[1], m[2], m[3]]
        return mesh.map(quad => quad.map(p => radialWave(p, vec)))
      }
    }

    function applyTransforms(mesh, model) {
      return model.transform.reduce((mesh, trans) => transformMesh(mesh, trans), mesh)
    }

    function applyPerspective(mesh) {
      var zoom = scale(1.8,1.8,1.8)
      var perspective = {
        top: zoom,
        front: mmult(zoom, rotateX(-Math.PI/2)),
        side: mmult(zoom, mmult(rotateY(Math.PI/2), rotateZ(Math.PI/2))),
        perspective: mmult(zoom, mmult(rotateZ(-0.75), rotateX(-1.1)))
      }[self.camera] || mmult(rotateZ(0.3), rotateX(1.21))
      return mesh.map(q => transformQuad(q, perspective).map(p => vtranslate(p, [500,400,0])))
    }

    self.on('before-mount', function() {
      self.world = app.getWorld()
      app.events.on('world-updated', self.update)
    })

    self.on('unmount', function() {
      app.events.off('world-updated', self.update)
    })

    var rotateX = (a) => [1,0,0,  0,Math.cos(a),-Math.sin(a),  0,Math.sin(a),Math.cos(a)]
    var rotateY = (a) => [Math.cos(a),0,Math.sin(a), 0,1,0, -Math.sin(a),0,Math.cos(a)]
    var rotateZ = (a) => [Math.cos(a),-Math.sin(a),0,  Math.sin(a),Math.cos(a),0,  0,0,1]
    var rotateXYZ = (x,y,z) => mmult(mmult(rotateX(x), rotateY(y)), rotateZ(z))
    var scale = (x,y,z) => [x,0,0,  0,y,0,  0,0,z]
    var identity = () => [1,0,0, 0,1,0, 0,0,1]
    var vtranslate = (vec, delta) => [vec[0]+delta[0], vec[1]+delta[1], vec[2]+delta[2]]
    var vadd = (a, b) => [a[0]+b[0], a[1]+b[1], a[2]+b[2]]
    var vdiff = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]]
    var vdot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
    var vmult = (k, v) => [k*v[0], k*v[1], k*v[2]]
    var vmag = v => Math.sqrt(vdot(v, v))
    var vnormalize = v => vmult(1/vmag(v), v)
    var vcross = (a, b) => [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]

    function mapply (matrix, vec) {
        return [vec[0]*matrix[0+3*0] + vec[1]*matrix[1+3*0] + vec[2]*matrix[2+3*0],
                vec[0]*matrix[0+3*1] + vec[1]*matrix[1+3*1] + vec[2]*matrix[2+3*1],
                vec[0]*matrix[0+3*2] + vec[1]*matrix[1+3*2] + vec[2]*matrix[2+3*2]]
    }

    function mmult (a, b) {
        var m = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        for (var i=0; i<3; i++) {
            for (var j=0; j<3; j++) {
                for (var k=0; k<3; k++) {
                    m[i+3*j] += a[i+3*k]*b[k+3*j]
                }
            }
        }
        return m
    }

  </script>

</models-viewer>
