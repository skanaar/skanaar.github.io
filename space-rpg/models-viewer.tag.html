<models-viewer>

  <div class="list">
    <div each={model in world.models} onclick={edit} class={ list_item: true, active: model==selected }>
      {model.name}
    </div>
    <div><button onclick={addLathe}>+ New Lathed Model</button></div>
    <div><button onclick={addComposition}>+ New Composite Model</button></div>
  </div>

  <svg width=800 height=800 class="canvas-3d">
    <path
      each={e in box}
      riot-d="M{e[0][0]},{e[0][1]} L{e[1][0]},{e[1][1]} L{e[2][0]},{e[2][1]} L{e[3][0]},{e[3][1]} Z"
      fill=none stroke="#000"/>
    <path
      each={e in mesh}
      riot-d="M{e[0][0]},{e[0][1]} L{e[1][0]},{e[1][1]} L{e[2][0]},{e[2][1]} L{e[3][0]},{e[3][1]} Z"
      fill={shading(e)} stroke="#000"/>
  </svg>

  <div class="toolbox">
    <div class="btn-group">
      <a onclick={setCamera.bind(null, 'top')} class="toggle-btn {(camera == 'top') && 'active'}">Top
      </a><a onclick={setCamera.bind(null, 'front')} class="toggle-btn {(camera == 'front') && 'active'}">Front
      </a><a onclick={setCamera.bind(null, 'side')} class="toggle-btn {(camera == 'side') && 'active'}">Side
      </a><a onclick={setCamera.bind(null, 'perspective')} class="toggle-btn {(camera == 'perspective') && 'active'}">Perspective</a>
    </div>
    <button onclick={up}>Up</button>
    <button onclick={down}>Down</button>
  </div>

  <div class="sidebar" show={!!selected}>
    <label>Source</label>
    <textarea value={asJson(selected)} ref="sourceField"></textarea>

    <br/>
    <button onclick={remove}>Delete</button>
    <button onclick={endEditing}>Done</button>
    <button onclick={cancelEditing}>Cancel</button>
  </div>

  <style>
    .sidebar textarea {
      width: 230px;
      height: 80%;
    }
    .canvas-3d {
      display: block;
      margin: 0 auto;
    }
  </style>

  <script>
    var self = this
    self.camera = 'perspective' // top | front | side |Â perspective
    self.world = { models: [] }
    self.mesh = []
    self.box = []

    self.setCamera = function (mode) {
      self.camera = mode
      updateMesh()
    }

    self.asJson = function (data) {
      return _.stringify(data, { maxLength: 50, indent: 1 })
    }

    self.addLathe = function () {
      self.world.models.push({
        name: "xyz",
        geometry: "lathe",
        res: 8,
        transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 0, 0, 0]],
        path: [[0,0,-50], [50,0,0], [0,0,50]]
      })
    }

    self.addComposition = function () {
      self.world.models.push({
        name: "xyz",
        geometry: "composite",
        transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 0, 0, 0]],
        parts: [
          {
            geometry: "lathe",
            res: 4,
            transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", 50, 0, 0]],
            path: [[0,0,-50], [50,0,0], [0,0,50]]
          },
          {
            geometry: "lathe",
            res: 6,
            transform: [["scale", 1, 1, 1], ["rotate", 3.14, 0, 0], ["translate", -50, 0, 0]],
            path: [[0,0,-50], [50,0,0], [0,0,50]]
          }
        ]
      })
    }

    self.up = function () {
      _.bubbleUp(self.world.models, self.world.models.findIndex(e => e == self.selected))
    }

    self.down = function () {
      _.bubbleDown(self.world.models, self.world.models.findIndex(e => e == self.selected))
    }
    
    self.edit = function (e) {
      self.selected = e.item.model
      updateMesh()
    }
    
    self.endEditing = function (e) {
      _.extend(self.selected, JSON.parse(self.refs.sourceField.value))
      updateMesh()
      self.update()
    }

    self.cancelEditing = function () {
      self.selected = null
      self.update()
    }

    self.remove = function () {
      if (!confirm('Remove model ' + self.selected.name)) return
      self.world.models = self.world.models.filter(e => e != self.selected)
      self.selected = null
    }

    self.shading = function (quad) {
      var normal = vnormalize(vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3])))
      var shade = Math.ceil(200*vdot(normal, vnormalize([1,-1,-1])))
      if (shade < 0) shade = 0
      return 'rgba('+[shade,shade,shade].join()+',0.85)'
    }

    function buildMesh(model){
      if (model.geometry == 'lathe')
        return applyTransformations(lathe(model), model)
      if (model.geometry == 'composite')
        return applyTransformations(_.flatten(model.parts.map(buildMesh), true), model)
      if (model.geometry == 'sphere')
        return applyTransformations(sphere(model), model)
    }

    function updateMesh(){
      self.mesh = applyPerspective(buildMesh(self.selected))
      self.mesh = self.mesh.filter(function (quad) {
        let normal = vcross(vdiff(quad[2], quad[0]), vdiff(quad[1], quad[3]))
        return normal[2] < 0
      })
      self.mesh = _.sortBy(self.mesh, quad => -(quad[0][2]+quad[2][2]))
      self.box = applyPerspective([[[-200,-200,100], [-200,200,100], [200,200,100], [200,-200,100]]])
    }

    function lathe(model) {
      var mesh = []
      var maxAngle = model.angle || Math.PI*2
      _.range(0, model.res).map(function (slice) {
        var vertex = (i,j) => mapply(rotateZ(maxAngle * i/model.res), model.path[j])
        for (var i=1; i<model.path.length; i++) {
          mesh.push([vertex(slice,i), vertex(slice+1,i), vertex(slice+1,i-1), vertex(slice,i-1)])
        }
      })
      return mesh
    }

    function transformQuad(quad, matrix) {
      return quad.map(p => mapply(matrix, p))
    }

    function transformMesh(mesh, m) {
      if (m[0] == 'scale')
        return mesh.map(quad => transformQuad(quad, scale(m[1], m[2], m[3])))
      if (m[0] == 'rotate')
        return mesh.map(quad => transformQuad(quad, rotateXYZ(m[1], m[2], m[3])))
      if (m[0] == 'translate')
        return mesh.map(quad => quad.map(p => [p[0]+m[1], p[1]+m[2], p[2]+m[3]]))
    }

    function applyTransformations(mesh, model) {
      return model.transform.reduce((mesh, trans) => transformMesh(mesh, trans), mesh)
    }

    function applyPerspective(mesh) {
      var zoom = scale(1.8,1.8,1.8)
      var perspective = {
        top: zoom,
        front: mmult(zoom, rotateX(-Math.PI/2)),
        side: mmult(zoom, mmult(rotateY(Math.PI/2), rotateZ(Math.PI/2))),
        perspective: mmult(zoom, mmult(rotateZ(-0.75), rotateX(-1.1)))
      }[self.camera] || mmult(rotateZ(0.3), rotateX(1.21))
      return mesh.map(q => transformQuad(q, perspective).map(p => vtranslate(p, [400,350,0])))
    }

    function loadWorld() {
        self.world = getWorld()
        self.update()
    }

    self.on('mount', function() {
      window.events.on('world-updated', loadWorld)
      window.events.on('save-world', () => saveWorld(self.world))
      loadWorld()
    })

    var rotateX = (a) => [1,0,0,  0,Math.cos(a),-Math.sin(a),  0,Math.sin(a),Math.cos(a)]
    var rotateY = (a) => [Math.cos(a),0,Math.sin(a), 0,1,0, -Math.sin(a),0,Math.cos(a)]
    var rotateZ = (a) => [Math.cos(a),-Math.sin(a),0,  Math.sin(a),Math.cos(a),0,  0,0,1]
    var rotateXYZ = (x,y,z) => mmult(mmult(rotateX(x), rotateY(y)), rotateZ(z))
    var scale = (x,y,z) => [x,0,0,  0,y,0,  0,0,z]
    var identity = () => [1,0,0, 0,1,0, 0,0,1]
    var vtranslate = (vec, delta) => [vec[0]+delta[0], vec[1]+delta[1], vec[2]+delta[2]]
    var vdiff = (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]]
    var vdot = (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
    var vmult = (k, v) => [k*v[0], k*v[1], k*v[2]]
    var vnormalize = v => vmult(1/Math.sqrt(vdot(v, v)), v)
    var vcross = (a, b) => [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]

    function mapply (matrix, vec) {
        return [vec[0]*matrix[0+3*0] + vec[1]*matrix[1+3*0] + vec[2]*matrix[2+3*0],
                vec[0]*matrix[0+3*1] + vec[1]*matrix[1+3*1] + vec[2]*matrix[2+3*1],
                vec[0]*matrix[0+3*2] + vec[1]*matrix[1+3*2] + vec[2]*matrix[2+3*2]]
    }

    function mmult (a, b) {
        var m = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        for (var i=0; i<3; i++) {
            for (var j=0; j<3; j++) {
                for (var k=0; k<3; k++) {
                    m[i+3*j] += a[i+3*k]*b[k+3*j]
                }
            }
        }
        return m
    }

  </script>

</models-viewer>
