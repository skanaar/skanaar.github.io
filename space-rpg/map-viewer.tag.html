<galactic-map>

  <svg class={ 'map-dark': isDark }
      riot-width={2*dx}
      riot-height={2*dy}
      onmousedown={mousedown}
      onmousemove={mousemove}
      onmouseup={mouseup}>
    <ellipse
      each={e in regions()}
      class="map-region"
      riot-cx={e.screenPos.x} riot-cy={e.screenPos.y}
      riot-rx={scale * e.entity.radius} riot-ry={scale * e.entity.radius}/>
    <line each={lines} class="map-pathway" riot-x1={a.x} riot-x2={b.x} riot-y1={a.y} riot-y2={b.y} />
    <text class="map-label" if={scale > 0.25} each={nodes} riot-x={screenPos.x+radiusFor(entity)+4} riot-y={screenPos.y+7}>
      {entity.name}
    </text>
    <ellipse
      each={nodes}
      class={ 'map-node': true, 'map-selected': isSelected }
      stroke-width={isSelected ? 2 : (type == 'region' ? 2 : 0.5)}
      stroke-dasharray={type == 'region' ? '3,3' : false}
      fill={fillFor(entity)}
      riot-cx={screenPos.x} riot-cy={screenPos.y}
      riot-rx={1+radiusFor(entity)} riot-ry={1+radiusFor(entity)}
      onmouseup={mouseupOnItem}/>
    <path
      each={enemyDestinations()}
      d="M-2,2 L0,-2 L2,2 Z"
      riot-transform={'translate(' + (screenPos.x+radiusFor(entity)+3) + ',' + (screenPos.y-radiusFor(entity)-3) + ')'}
      fill="rgba(255,0,0,0.5)" stroke="#F00"/>
    <ellipse
      each={treasureDestinations()}
      riot-cx={screenPos.x+3} riot-cy={screenPos.y+3}
      rx=2 ry=2
      stroke="#000" fill="#FF0" />
    <path
      each={traderDestinations()}
      d="M-6,-4 L-6,4 L0,0 Z"
      riot-transform={'translate(' + (screenPos.x-radiusFor(entity)) + ',' + screenPos.y + ')'}
      fill="#0A0" stroke="#FFF"/>
    <rect class="map-rubberrect"
      riot-x={select.pos.x} riot-y={select.pos.y} riot-width={select.dim.x} riot-height={select.dim.y}/>
  </svg>

  <div class="toolbox">
    <div class="btn-group">
      <a class="toggle-btn" onclick={() => zoom(1.2)}>+</a><a class="toggle-btn" onclick={() => zoom(1/1.2)}>-</a>
    </div>
    <div class="btn-group">
      <a onclick={() => tool='select'} class="toggle-btn {(tool == 'select') && 'active'}">Select
      </a><a onclick={() => tool='draw'} class="toggle-btn {(tool == 'draw') && 'active'}">Add Celestial
      </a><a onclick={() => tool='spray'} class="toggle-btn {(tool == 'spray') && 'active'}">Add Cluster
      </a><a onclick={() => tool='region'} class="toggle-btn {(tool == 'region') && 'active'}">Add Region</a>
    </div>
    <button onclick={selectAsteroids}>Select asteroids</button>
    <div class="btn-group" style="opacity: {selectionSize > 1 ? 1 : 0.5}">
      <a class="toggle-btn" onclick={() => enlargeShrink(1.02)}>Enlarge</a><a class="toggle-btn" onclick={() => enlargeShrink(0.98)}>Shrink</a>
    </div>
    <div class="btn-group" style="opacity: {selectionSize > 1 ? 1 : 0.5}">
      <a class="toggle-btn" onclick={() => repulseAttract(2)}>Repulse</a><a class="toggle-btn" onclick={() => repulseAttract(-2)}>Attract</a>
    </div>
    <div class="btn-group" style="opacity: {selectionSize > 1 ? 1 : 0.5}">
      <a class="toggle-btn" onclick={() => rotate(0.2618)}>Rotate +</a><a class="toggle-btn" onclick={() => rotate(-0.2618)}>Rotate -</a>
    </div>
    <button onclick={() => isDark = !isDark}>dark</button>
  </div>

  <div class="sidebar" show={selectionSize == 1 && regionSelected}>
    <label>Name</label>
    <input type=text ref="regionNameField" onchange={setRegionName}>
    <div class="input-grid">
      <em>Radius</em> <input type=number ref="regionRadiusField" onchange={setRegionRadius}>
    </div>
    <label>Audio</label>
    <select ref="audioSelect" onchange={setRegionAudio}>
      <option each={e in audios}>{e}</option>
    </select>
    <region-summary app={opts.app} region={singleSelected()} if={regionSelected} />
  </div>

  <div class="sidebar" show={selectionSize && !regionSelected}>
    <label>Name</label>
    <input show={selectionSize == 1} type=text ref="nameField" placeholder="name" onchange={setName}>
    <button onclick={autoNameNodes}>Autoname</button>

    <label>Celestial</label>
    <select ref="celestialSelect" onchange={setCelestial}>
      <option value="unknown">- style -</option>
      <option each={e in world.celestials}>{e.name}</option>
    </select>
    <button onclick={randomizeStyle}>Randomize</button>

    <label>Treasures</label>
    <button onclick={chooseTreasures}>Choose treasures</button>

    <div show={selectionSize == 1}>
      <label><input type=checkbox ref=traderToggle onchange={traderChange}> Trader</label>
      <div class="input-grid">
        <em>buy at</em> <input type=number value={selectedTrader.buy} onchange={traderBuyChange}><br/>
        <em>sell at</em> <input type=number value={selectedTrader.sell} onchange={traderSellChange}><br/>
        <em>add item</em> 
        <button onclick={chooseTraderInventory}>Choose items</button>
      </div>

      <label><input type=checkbox ref=shipyardToggle onchange={shipyardChange}> Shipyard</label>
      <button onclick={chooseShipyardInventory}>Choose ships</button>

      <label><input type="checkbox" onchange={enemyToggle} ref="enemyCheckbox"> Enemy</label>
      <select ref="enemySelect" onchange={enemyChanged}>
        <option each={e in world.enemies}>{e.name}</option>
      </select>
      <button onclick={chooseLoot}>Choose loot</button>
    </div>
    <label></label>
    <button onclick={removeSelected} style="opacity: {selectionSize > 0 ? 1 : 0.5}">Delete</button>
    <button onclick={makeStartingDest} style="opacity: {selectionSize == 1 ? 1 : 0.5}">Make starting point</button>
  </div>

  <script>
    var self = this
    var app = this.opts.app || window.app

    self.isDark = false
    self.nodes = []
    self.regions = []
    self.lines = []
    self.jumpRange = 125
    self.scale = 0.5
    self.tool = 'select' // draw | spray | audio
    self.dx = window.innerWidth
    self.dy = window.innerWidth
    self.input = { a: Vec(0,0), b: Vec(0,0) }
    self.isDown = false
    self.select = { pos: Vec(0,0), dim: Vec(0,0) }
    self.world = app.nullWorld()
    self.audios = app.audios
    self.selectionSize = 0
    self.regionSelected = false
    self.selectedTrader = { inventory: [] }
    self.selectedItems = []
    self.radiusCache = {}

    self.keydown = function (e) {
      if (document.activeElement && document.activeElement.nodeName === 'INPUT') return;
      var step = e.shiftKey ? 2 : (e.metaKey ? 100 : 20)
      switch (e.key) {
        case 'Backspace':
        case 'Delete':     self.removeSelected(); break;
        case 'ArrowLeft':  translateSelection(Vec(-step, 0)); break;
        case 'ArrowRight': translateSelection(Vec(step, 0)); break;
        case 'ArrowUp':    translateSelection(Vec(0, -step)); break;
        case 'ArrowDown':  translateSelection(Vec(0, step)); break;
        default: return;
      }
      e.preventDefault()
    }

    function translateSelection(delta) {
      _.filter(self.nodes, 'isSelected').forEach(function (node) {
        node.entity.pos = rund(add(node.entity.pos, delta))
        node.screenPos = transform(node.entity.pos)
      })
      calculateLines()
      self.update()
    }

    self.zoom = function (factor) {
      self.scale *= factor
      self.dx *= factor
      self.dy *= factor
      loadDestinations(self.world)
    }

    self.selectAsteroids = function () {
      self.nodes.forEach(e => e.isSelected = e.entity.style && e.entity.style.startsWith('asteroid-'))
      updateUI()
    }

    self.mousedown = function (e) { // 132
      e.preventDefault()
      self.input.a = Vec(e.offsetX, e.offsetY)
      self.isDown = true
    }
    self.mousemove = function (e) {
      e.preventDefault()
      if (!self.isDown) return;
      self.input.b = Vec(e.offsetX, e.offsetY)
      var d = diff(self.input.b, self.input.a)
      self.select.dim = Vec(Math.abs(d.x), Math.abs(d.y))
      self.select.pos = Vec(Math.min(self.input.a.x, self.input.b.x), Math.min(self.input.a.y, self.input.b.y))
    }
    self.mouseupOnItem = function (e) {
      e.stopPropagation()
      if (!self.isDown) { return }
      if (e.shiftKey) {
        e.item.isSelected = !e.item.isSelected
      }
      else {
        self.nodes.forEach(function (e){ e.isSelected = false })
        e.item.isSelected = true
      }
      updateUI()
      self.isDown = false
      self.select = { pos: Vec(0,0), dim: Vec(0,0) }
      self.input.a = Vec(0,0)
      self.input.b = Vec(0,0)
    }

    function addAsteroid(pos) {
        self.nodes.push({
          type: 'celestial',
          screenPos: transform(pos),
          isSelected: false,
          entity: { pos: pos, name: 'unnamed', style: 'asteroid-1', trader: null, enemy: null, treasures: [] }
        })
    }

    function addRegion(pos) {
        self.nodes.push({
          type: 'region',
          screenPos: transform(pos),
          isSelected: false,
          entity: {
            pos: pos, radius: 100, name: 'unnamed region', audio: 'light-years', style: 'region-1',
            trader: null, enemy: null, treasures: []
          }
        })
    }

    self.mouseup = function (e) {
      e.preventDefault()
      if (!self.isDown) { return }
      document.activeElement.blur()
      self.input.b = Vec(e.offsetX, e.offsetY)
      if (0 == dist(self.input.a, self.input.b) && self.tool != 'select') {
        var pos = rund(mult(diff(self.input.a, Vec(self.dx, self.dy)), 1/self.scale))
        if (self.tool == 'draw')
          addAsteroid(pos)
        else if (self.tool == 'spray'){
          for (var i = 0, a = 0; i < 10; i++, a=6.28*Math.random()){
            var delta = mult(Vec(Math.cos(6.28*i/10), Math.sin(6.28*i/10)), 80)
            addAsteroid(rund(add(pos, add(delta, Vec(60*Math.random(), 60*Math.random())))))
          }
        } else if (self.tool == 'region'){
          addRegion(pos)
        }
        calculateLines()
      } else {
        self.nodes.forEach(function (node) {
          var p = transform(node.entity.pos)
          var isLassood = (
            p.x > self.select.pos.x &&
            p.y > self.select.pos.y &&
            p.x < self.select.pos.x + self.select.dim.x &&
            p.y < self.select.pos.y + self.select.dim.y)
          node.isSelected = e.shiftKey ? (node.isSelected || isLassood) : isLassood
          updateUI()
        })
      }
      self.isDown = false
      self.select = { pos: Vec(0,0), dim: Vec(0,0) }
      self.input.a = Vec(0,0)
      self.input.b = Vec(0,0)
    }

    self.removeSelected = function () {
      self.nodes = self.nodes.filter(e => !e.isSelected)
      updateUI()
      calculateLines()
    }

    self.makeStartingDest = function () {
      self.world.initialDestination = singleSelected().name
    }

    function singleSelected() { return (_.find(self.nodes, e => e.isSelected) || {}).entity || {} }
    self.singleSelected = singleSelected
    self.chooseTreasures = () => app.events.trigger('show-item-chooser', singleSelected().treasures)
    self.chooseTraderInventory = () => app.events.trigger('show-item-chooser', singleSelected().trader.inventory)
    self.chooseLoot = () =>app.events.trigger('show-item-chooser', singleSelected().enemy.loot)

    self.chooseShipyardInventory = () => app.events.trigger('show-ship-chooser', singleSelected().shipyard)

    self.autoNameNodes = function () {
      var coords = (e) => Math.abs(e.pos.x%1000)+Math.abs(e.pos.y%1000)
      var shortCode = (e) => (1+Math.abs(e.pos.x)%10)+(1+Math.abs(e.pos.y)%100)
      forSelected(function (e){
        if (e.style.startsWith('asteroid')) e.name = 'A' + coords(e)
        if (e.style.startsWith('cloud')) e.name = 'Cloud ' + coords(e)
        if (e.style == 'anomaly-buoy') e.name = 'Buoy ' + shortCode(e)
        if (e.style == 'anomaly-ruin') e.name = 'Debris ' + coords(e)
        if (e.style == 'anomaly-junk') e.name = 'Debris ' + coords(e)
        if (e.style == 'anomaly-debris') e.name = 'Debris ' + coords(e)
      })
    }

    self.setCelestial = function (e) {
      forSelected(ent => ent.style = e.target.value)
      calculateLines()
    }

    function defaultTrader(){ return { buy: 1.5, sell: 0.75, inventory: [] } }
    self.traderChange = e => forSelected(ent => ent.trader = e.target.checked ? defaultTrader() : null)
    self.traderBuyChange = e => forSelected(ent => ent.trader.buy = +e.target.value)
    self.traderSellChange = e => forSelected(ent => ent.trader.sell = +e.target.value)

    self.shipyardChange = e => forSelected(ent => ent.shipyard = e.target.checked ? [] : null)

    self.isEnemyChecked = () => singleSelected().enemy
    self.enemyToggle = e => singleSelected().enemy = e.target.checked ? { type: 'rogue', loot: [] } : null
    self.enemyChanged = e => { if (singleSelected().enemy) singleSelected().enemy.type = e.target.value }

    self.setName = function () {
      singleSelected().name = self.refs.nameField.value
    }

    self.setRegionName = () => singleSelected().name = self.refs.regionNameField.value
    self.setRegionRadius = () => singleSelected().radius = self.refs.regionRadiusField.value
    self.setRegionAudio = e => singleSelected().audio = e.target.value

    self.randomizeStyle = function () {
      _.filter(self.nodes, 'isSelected').forEach(function (node) {
        var type = node.entity.style.split('-')[0]
        var stylesOfSameType = self.world.celestials.filter(e => e.name.startsWith(type))
        node.entity.style = _.sample(stylesOfSameType).name
      })
      updateUI()
      calculateLines()
    }

    self.repulseAttract = function (coefficient) {
      var subset = _.filter(self.nodes, 'isSelected')
      _.pairs(subset, function (a, b) {
        var delta = diff(a.entity.pos, b.entity.pos)
        var d = normalize(delta)
        var force = coefficient * 5000 / Math.max(1000, delta.x*delta.x + delta.y*delta.y)
        a.entity.pos = rund(add(a.entity.pos, mult(d, force)))
        b.entity.pos = rund(add(b.entity.pos, mult(d, -force)))
        a.screenPos = transform(a.entity.pos)
        b.screenPos = transform(b.entity.pos)
      })
      calculateLines()
    }
    self.enlargeShrink = function (coefficient) {
      var subset = _.filter(self.nodes, 'isSelected')
      var positions = subset.map(e => e.entity.pos)
      var centroid = mult(positions.reduce(add, Vec(0,0)), 1/subset.length)
      subset.forEach(function (a) {
        a.entity.pos = rund(add(centroid, mult(diff(a.entity.pos, centroid), coefficient)))
        a.screenPos = transform(a.entity.pos)
      })
      calculateLines()
    }
    self.rotate = function (angle) {
      var subset = _.filter(self.nodes, 'isSelected')
      var positions = subset.map(e => e.entity.pos)
      var centroid = mult(positions.reduce(add, Vec(0,0)), 1/subset.length)
      subset.forEach(function (a) {
        a.entity.pos = rund(add(centroid, rotate(diff(a.entity.pos, centroid), angle)))
        a.screenPos = transform(a.entity.pos)
      })
      calculateLines()
    }

    self.regions = () => self.nodes.filter(e => e.type == 'region')
    self.enemyDestinations = () => self.nodes.filter(e => e.entity.enemy)
    self.traderDestinations = () => self.nodes.filter(e => e.entity.trader)
    self.treasureDestinations = () => self.nodes.filter(e => (e.entity.treasures || []).length)

    var fills = {
      cloud: 'rgba(221, 136, 221, 0.5)', star: '#dd0', jovian: '#fa8',
      planet: '#4d4', asteroid: '#888', anomaly: '#fa0', ring: '#8af', region: '#aaa'
    }
    self.fillFor = entity => fills[entity.style.split('-')[0]]
    self.radiusFor = function (ent) {
      return 1 + self.scale * (self.radiusCache[ent.style] || 5)
    }

    function forSelected(action) {
      self.nodes.filter(e => e.isSelected && e.type === 'celestial').forEach(o => action(o.entity))
      updateUI()
    }

    function uniqueSelectedProp(key) {
      var x = null
      self.nodes.forEach(function (e) {
        if (e.isSelected && e.entity[key])
          x = x == null ? e.entity[key] : (e.entity[key] == x ? e.entity[key] : 'unknown')
      })
      return x
    }

    function updateUI() {
      self.refs.celestialSelect.value = uniqueSelectedProp('style') || 'unknown'
      var selection = _.filter(self.nodes, 'isSelected')
      self.selectionSize = selection.length
      self.regionSelected = selection.every(e => e.type === 'region')
      if (self.regionSelected && self.selectionSize == 1) {
        self.refs.regionNameField.value = selection[0].entity.name
        self.refs.audioSelect.value = selection[0].entity.audio
        self.refs.regionRadiusField.value = selection[0].entity.radius
      }
      self.refs.nameField.value = selection.length == 1 ? selection[0].entity.name : ''
      self.refs.traderToggle.checked = !!(selection.length == 1 && selection[0].entity.trader)
      self.selectedTrader = (selection[0] && selection[0].entity.trader) || { buy: 0, sell: 0, inventory: [] }
      self.refs.shipyardToggle.checked = !!(selection.length == 1 && selection[0].entity.shipyard)
      self.refs.enemySelect.value = selection[0] && selection[0].entity.enemy && selection[0].entity.enemy.type
      self.refs.enemyCheckbox.checked = selection[0] && selection[0].entity.enemy
    }

    function transform(p) { return Vec(self.dx+self.scale*p.x, self.dy+self.scale*p.y) }

    function loadDestinations(world) {
      self.nodes = world.destinations.map(e => ({
        type: 'celestial',
        screenPos: transform(e.pos),
        isSelected: false,
        entity: e
      }))
      var regions = world.regions.map(e => ({
        type: 'region',
        screenPos: transform(e.pos),
        isSelected: false,
        entity: {
          pos: e.pos, name: e.name, audio: e.audio, radius: e.radius, style: 'region-1',
          trader: null, enemy: null, treasures: []
        }
      }))
      self.nodes.push(...regions)
      calculateLines()
    }

    function calculateLines() {
      self.lines = []
      _.pairs(self.nodes, function (a, b) {
        if (self.jumpRange > dist(a.entity.pos, b.entity.pos) && isTravellable(a.entity) && isTravellable(b.entity))
          self.lines.push({ a: transform(a.entity.pos), b: transform(b.entity.pos) })
      })
    }

    function isTravellable(entity) {
      return ['jovian', 'planet', 'asteroid', 'anomaly'].includes(entity.style.split('-')[0])
    }

    function onHighlightRequested(e) {
      if (e.type == 'destination') {
        self.nodes.forEach(node => node.isSelected = (node.entity.name == e.name))
        updateUI()
      }
    }

    function buildRadiusCache() {
      self.radiusCache = _.object(self.world.celestials.map(e => [e.name, e.radius]))
      self.radiusCache['region-1'] = 6
    }

    function prepareWorldForSave() {
      self.world.destinations = self.nodes.filter(e => e.type === 'celestial').map(e => e.entity)
      self.world.destinations.forEach(function (e) {
        delete e.id
      })
      self.world.regions = self.nodes.filter(e => e.type === 'region').map(e => ({
        name: e.entity.name,
        audio: e.entity.audio,
        pos: e.entity.pos,
        radius: +e.entity.radius
      }))
      return self.world
    }

    function loadWorld() {
      loadDestinations(self.world)
      updateUI()
      self.update()
    }

    self.on('mount', function() {
      self.world = app.getWorld()
      app.events.on('save-world', prepareWorldForSave)
      app.events.on('world-updated', loadWorld)
      app.events.on('highlight-entity', onHighlightRequested)
      window.document.addEventListener('keydown', self.keydown)
      loadWorld()
      buildRadiusCache()
      window.scrollTo(self.dx/3, self.dy/3)
    })

    self.on('unmount', function () {
      app.events.off('world-updated', loadWorld)
      app.events.off('save-world', prepareWorldForSave)
      app.events.off('world-updated', loadWorld)
      window.document.removeEventListener('keydown', self.keydown)
    })

  </script>

</galactic-map>
