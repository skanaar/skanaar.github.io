<overview-viewer>

  <svg
      riot-width={2*dx}
      riot-height={2*dy}>
    <ellipse
      each={e in regions()}
      class="overview-region"
      fill={colorForLevel(enemyLevel(e.entity))}
      riot-cx={e.screenPos.x} riot-cy={e.screenPos.y}
      riot-rx={scale * e.entity.radius} riot-ry={scale * e.entity.radius}/>
  </svg>

  <div style="position: absolute; top: 25px">
    <div
      each={e in regions()}
      class="map-region"
      style={'position: absolute; text-align: center; width: 200px; top: ' + (e.screenPos.y - 15) + 'px; left: ' + (e.screenPos.x - 100) + 'px'}>
      <b>{e.entity.name}</b>
      <region-summary app={app} region={e.entity} compact="true"/>
    </div>
  </div>

  <div class="toolbox">
    <div class="btn-group">
      <a class="toggle-btn" onclick={() => zoom(1.2)}>+</a><a class="toggle-btn" onclick={() => zoom(1/1.2)}>-</a>
    </div>
  </div>

  <style>
    .overview-region {
      stroke-width: 1;
      stroke-dasharray: 3,3;
      stroke: gray;
    }
  </style>

  <script>
    var self = this
    var app = this.opts.app || window.app
    window.world = app.world

    self.app = app
    self.nodes = []
    self.regions = []
    self.lines = []
    self.jumpRange = 125
    self.scale = 0.25
    self.dx = Math.max(window.innerWidth/2, 2800*self.scale)
    self.dy = Math.max(window.innerHeight/2, 2800*self.scale)
    self.world = app.nullWorld()
    
    self.zoom = function (factor) {
      self.scale *= factor
      self.dx *= factor
      self.dy *= factor
      self.dx = Math.max(window.innerWidth/2, 2800*self.scale)
      self.dy = Math.max(window.innerHeight/2, 2800*self.scale)
      loadDestinations(self.world)
    }

    var spawnedEnemies = _.object(
      _.flatten(self.app.world.quests.map(e => e.xml.split('\n')))
      .filter(e => e.includes('<place-enemy'))
      .map(e => [e.match(/dest="([^"]*)"/)[1], e.match(/enemy="([^"]*)"/)[1]])
    )

    self.enemyLevel = function (region) {
      var members = app.world.destinations.filter(e => dist(e.pos, region.pos) < region.radius)
      var enemyIds = _.flatten(members.map(e => [e.enemy && e.enemy.type, spawnedEnemies[e.name]]))
      var enemies = _.compact(enemyIds.map(id => app.world.enemies.find(enemy => enemy.name == id)))
      return enemies.length ? _.max(enemies.map(e => e.level)) : 0
    }

    self.colorForLevel = function (level) {
      return ['#EEE', '#44e', '#afa', '#4f5', '#FF4', '#FC4', '#F94', '#F64', '#F33', '#E22', '#C44'][level]
    }

    function singleSelected() { return (_.find(self.nodes, e => e.isSelected) || {}).entity || {} }
    self.singleSelected = singleSelected
    self.chooseTreasures = () => app.events.trigger('show-item-chooser', singleSelected().treasures)
    self.chooseTraderInventory = () => app.events.trigger('show-item-chooser', singleSelected().trader.inventory)

    self.regions = () => self.nodes.filter(e => e.type == 'region')
    self.enemyDestinations = () => self.nodes.filter(e => e.entity.enemy)
    self.traderDestinations = () => self.nodes.filter(e => e.entity.trader)
    self.treasureDestinations = () => self.nodes.filter(e => (e.entity.treasures || []).length)

    function transform(p) { return Vec(self.dx+self.scale*p.x, self.dy+self.scale*p.y) }

    function loadDestinations(world) {
      self.nodes = world.regions.map(e => ({
        type: 'region',
        screenPos: transform(e.pos),
        entity: {
          pos: e.pos, name: e.name, audio: e.audio, radius: e.radius, style: 'region-1',
          trader: null, enemy: null, treasures: []
        }
      }))
    }

    function loadWorld() {
      loadDestinations(self.world)
      self.update()
    }

    self.on('mount', function() {
      self.world = app.getWorld()
      app.events.on('world-updated', loadWorld)
      loadWorld()
      window.scrollTo(self.dx/3, self.dy/3)
    })

    self.on('unmount', function () {
      app.events.off('world-updated', loadWorld)
      window.document.removeEventListener('keydown', self.keydown)
    })

  </script>

</overview-viewer>
