<terrain-preview>

  <svg width=800 height=500 class="surface-mesh" if={opts.surface}>
    <path
      each={e in mesh}
      d="M{e.a.x},{e.a.y} L{e.b.x},{e.b.y} L{e.c.x},{e.c.y} L{e.d.x},{e.d.y} Z"
      fill="#{e.fill}"/>
  </svg>

  <style>
    .surface-mesh {
      display: block;
      margin: 50px auto;
    }
  </style>

  <script>
    var self = this
    self.surface = null
    self.currentHash = null

    function hash(obj) {
      return _.flatten(_.map(obj, e => [e])).join(' ')
    }
    
    self.on('update', function () {
      if (self.opts.surface && hash(self.opts.surface) != self.currentHash) {
        self.surface = self.opts.surface
        self.currentHash = hash(self.surface)
        drawTerrain(self.surface)
      }
    })

    function toHex(x){ return constrain(0, 16, Math.round(x)).toString(16) }

    function colorLerp(c1, c2, factor){
      return [
        toHex(lerp([parseInt(c1[0], 16), parseInt(c2[0], 16)], factor)),
        toHex(lerp([parseInt(c1[1], 16), parseInt(c2[1], 16)], factor)),
        toHex(lerp([parseInt(c1[2], 16), parseInt(c2[2], 16)], factor))
      ].join('')
    }

    function sq(x){ return x*x }

    function constrain(min, max, x) { return Math.min(max, Math.max(min, x)) }

    function lerp(values, x) {
      var a = constrain(0, 0.999, x)
      var k = (a*(values.length-1)) % 1
      var i = Math.floor(a*(values.length-1))
      var c1 = values[i]
      var c2 = values[i+1]
      return c1*(1-k) + c2*k
    }

    function spectrumSample(spectrum, x){
      return _.map([
        lerp(_.map(spectrum, x => parseInt(x[0],16)), x),
        lerp(_.map(spectrum, x => parseInt(x[1],16)), x),
        lerp(_.map(spectrum, x => parseInt(x[2],16)), x)
      ], toHex).join('')
    }

    function drawTerrain(style){
      var center = Vec(400, 250)
      var radius = 348
      var angle = 0.3
      var res = 16
      var shadow = '000'

      var noise = Noise({ persistence: style.falloff, octaves: style.octaves, zoom: 0.2 })

      function terrainPoint(i, j, h){
        var p = rotate(mult(Vec(i-res, j-res), radius/res), angle)
        return Vec(p.x, p.y/2 - h * style.height*40/style.zoom)
      }

      var terrain = []
      for(var i=0; i<2*res+1; i++){
        terrain.push([])
        for(var j=0; j<2*res+1; j++){
          terrain[i][j] = noise(Vec(i*style.zoom/res, j*style.zoom/res))
          terrain[i][j] = lerp(style.curve, terrain[i][j])
        }
      }

      self.mesh = []

      for(var i=0; i<2*res; i++){
        for(var j=0; j<2*res; j++){
          if (sq(i-res) + sq(j-res) > sq(res)) continue
          var sunAngle = 0.75 + (terrain[i][j]-terrain[i+1][j])*res/15
          var color = colorLerp(shadow, spectrumSample(style.spectrum, terrain[i][j]), sunAngle)
          var alpha = constrain(0, 1, 0.6*(res - mag(Vec(i-res+1, j-res+1))))
          self.mesh.push({
            a: add(center, terrainPoint(i+0, j+0, terrain[i+0][j+0]-0.3)),
            b: add(center, terrainPoint(i+1, j+0, terrain[i+1][j+0]-0.3)),
            c: add(center, terrainPoint(i+1, j+1, terrain[i+1][j+1]-0.3)),
            d: add(center, terrainPoint(i+0, j+1, terrain[i+0][j+1]-0.3)),
            fill: color
          })
        }
      }
    }

    function Noise(conf) {
      var res = 256
      var persistence = conf.persistence || 0.5
      var octaves = conf.octaves || 1
      var scale = conf.zoom * 2 || 2
      var matrix = _.range(res).map(e => Math.random() - 0.5)

      function smoothstep(x) { return x*x*(3 - 2*x) }

      function lerp(factor, a, b) { return a + (b-a)*factor }
      
      function getSingleOctave(p) {
        var x0 = Math.floor(p.x)
        var y0 = Math.floor(p.y)
        var x1 = x0+1
        var y1 = y0+1
        var ux = smoothstep(p.x - x0)
        var uy = smoothstep(p.y - y0)
        var yy0 = lerp(uy, val(x0, y0), val(x0, y1))
        var yy1 = lerp(uy, val(x1, y0), val(x1, y1))
        return lerp(ux, yy0, yy1)
      }
      
      function val(x, y) {
        return matrix[Math.abs(1024 + x + 7*y) % matrix.length]
      }

      return function (p) {
        var sum = 0.0
        var pos = mult(p, 1/scale)
        var amp = 1.0
        for (var i=0; i<octaves; i++) {
          sum = sum + amp * getSingleOctave(pos)
          pos = mult(pos, 2)
          amp = amp * persistence
        }
        return sum + 0.5
      }
    }

  </script>

</terrain-preview>
