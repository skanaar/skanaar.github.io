<rule-simulator>
  <div class=page>

    <div class=row>
      <button onclick={parseSource}>
        <svg height="20px" viewBox="0 0 20 20" width="20px" style="vertical-align: middle; margin-right: 5px;">
          <path d="M405.2,232.9L126.8,67.2c-3.4-2-6.9-3.2-10.9-3.2c-10.9,0-19.8,9-19.8,20H96v344h0.1c0,11,8.9,20,19.8,20  c4.1,0,7.5-1.4,11.2-3.4l278.1-165.5c6.6-5.5,10.8-13.8,10.8-23.1C416,246.7,411.8,238.5,405.2,232.9z" transform="scale(0.035,0.035)" fill="white"></path>
        </svg> Compile
      </button>
      <button onclick={loadDefault}>Load default</button>
    </div>
    <div class="card card-editor">
      <div class="editor-error" style={e} each={e in errorLines}></div>
      <textarea class=editor rows=20 ref="editor" value={example}
       autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
      <div class=output>
        <div class="output-info" each={e in infos}>{e}</div>
        <div class="output-error" each={err in errors}>{err}</div>
      </div>
    </div>

    <div class="card card-padded">
      <div>
        <input type=range step=3 min=0 max=512 onchange={calc}>
      </div>
      <svg width=1000 height=200>
        <g transform="scale(1,1) translate(0,0)">
          <path each={e in graphs}
            riot-d={e.path}
            fill=none riot-stroke={e.color} class="svg-stock-graph"></path>
          <path 
            each={e in intervals} riot-stroke={e.color} riot-d={e.path}
            stroke-width="3" fill=none></path>
        </g>
      </svg>
    </div>
  </div>

  <style>
    .svg-stock-graph { opacity: 0.5; }
    .editor-error {
      position: absolute;
      left: 0;
      width: 10px;
      height: 17px;
      background: rgba(255,0,0,0.3);
    }
    .card-editor {
      display: flex;
    }
    .editor {
      display: inline-block;
      vertical-align: top;
      resize: none;
      outline: none;
      width: 60%;
      font-family: Consolas, Menlo, monospace;
      font-size: 14px;
      line-height: 17px;
      background: none;
      color: #03A678;
      border: 0;
      padding: 15px;
    }
    .output {
      display: inline-block;
      vertical-align: top;
      width: 40%;
      font-family: Consolas, Menlo, monospace;
      font-size: 14px;
      padding: 15px;
      border-radius: 0 4px 4px 0;
      background: #444;
    }
    .output-info {
      color: #49A;
      white-space: pre;
    }
    .output-error {
      color: #A94;
      white-space: pre;
    }
    input[type=range] { width: 100% }
  </style>
  <script>
    var self = this
    const clamp = (low, high, x) => Math.max(low, Math.min(high, x))
    const range = (end) => [...Array(end).keys()]
    const rnd = (low,high) => low + (high-low) * Math.random()
    const flatmap = (list, op) => _.flatten(list.map(op))
    const sum = (list) => list.reduce((a,b) => a+b)
    const average = (list) => list.reduce((a,b) => a+b) / list.length
    const max = (list) => list.reduce((a,b) => Math.max(a,b))
    const min = (list) => list.reduce((a,b) => Math.min(a,b))
    const listSum = (listA,listB) => listA.map((e,i) => listA[i] + listB[i])
    const round = (x) => Math.round(x)
    const toPath = (data,dx) => 'M' + data.map((e,i) => 2*(dx+i)+','+round(e)).join(' L')

    function smooth(es){
      return es.map((x,i) => (es[Math.max(0,i-1)] + 4*es[i] + es[Math.min(es.length-1,i+1)])/6)
    }
    function noise(source, amp, level) {
      if (!level) { return source }
      var d = _.flatten(source.map(x => [x+rnd(-amp, amp), x, x+rnd(-amp, amp)]))
      return smooth(noise(d, amp*0.75, level-1))
    }
    const Stock = (name, color, data) => ({ name, color, data })
    var omx = Stock('OMX', '#666', noise([120,120], 60, 5))
    var tobi = Stock('TOBI', '#4F4', listSum(omx.data, noise([0,0], 30, 5)))
    var fing = Stock('FING', '#F44', listSum(omx.data, noise([0,0], 30, 5)))
    var goog = Stock('GOOG', '#44F', listSum(omx.data, noise([0,0], 30, 5)))
    var stocks = { omx, tobi, fing, goog }
    var stockList = [omx, tobi, fing, goog]

    var defaultExample = document.getElementById('example-source').innerHTML.trim()
    self.example = localStorage['finscript:lastSource'] || defaultExample
    self.graphs = stockList.map(e => ({ color: e.color, path: toPath(e.data, 0) }))
    self.intervals = []

    function applyFunc(id, len, offset, func) {
      var stock = stocks[id]
      var t = Math.min(stock.data.length-len, offset)
      var span = stock.data.slice(t, t+len)
      var y = func(span)
      self.intervals.push({ color: stock.color, path: toPath(span.map(()=>y), t) })
      return y
    }

    function Buy(count, price, expires) {
      return { command: 'Buy', count, price, expires: expires || 10 }
    }

    // ----------
    var stockAverage = (id, len, offset) => applyFunc(id, len, offset, average)
    var stockMin = (id, len, offset) => applyFunc(id, len, offset, min)
    var stockMax = (id, len, offset) => applyFunc(id, len, offset, max)

    self.invokes = []

    self.calc = function (e) {
      self.intervals = []
      var t = Math.round(e.target.value)
      var toSymbol = s => s.substr(1).toLowerCase()
      self.invokes.forEach(e => {
        if (e.name === 'average') {
          stockAverage(toSymbol(e.args[0]), +e.args[1].value, t)
        }
        if (e.name === 'max') {
          stockMax(toSymbol(e.args[0]), +e.args[1].value, t)
        }
        if (e.name === 'min') {
          stockMin(toSymbol(e.args[0]), +e.args[1].value, t)
        }
      })
      return Buy(100, stockAverage('tobi', 1, t))
    }

    self.infos = []
    self.errors = []
    self.errorLines = []

    function error(msg, node) {
      self.errors.push('#' + node.loc.first_line + ',' + node.loc.first_column + ' ' + msg)
      self.errorLines.push({top: (node.loc.first_line * 17 - 2) + 'px'})
    }

    self.loadDefault = function () {
      self.example = defaultExample
      self.refs.editor.value = defaultExample
      localStorage['finscript:lastSource'] = defaultExample
    }

    self.parseSource = function () {
      self.infos = []
      self.errors = []
      self.errorLines = []
      var source = self.refs.editor.value
      try {
        var ast = finscript.parse(source, error)
        finscript.populateScopes(ast, error)
        finscript.markupTypes(ast, error)
        finscript.checkTypes(ast, error)
        if (self.errors.length === 0) {
          self.infos.push('SUCCESS')
        }
        self.infos.push('------')
        ast.funcs.filter(e => !e.params.length).forEach(fn => {
          try {
            self.infos.push(fn.name + '() ' + evaluate(fn.body, env))
          } catch (e) {
            self.infos.push(fn.name + '() ' + e.message)
          }
        })
        console.log(ast)
      } catch(e) {
        self.errors.push(e.message)
      }
    }
    // ----------

  </script>
</rule-simulator>
