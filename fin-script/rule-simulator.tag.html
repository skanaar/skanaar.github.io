<rule-simulator>

  <div class=row>
    <button onclick={parseSource}>
      <svg height="20px" viewBox="0 0 20 20" width="20px" style="vertical-align: middle; margin-right: 5px;">
        <path d="M405.2,232.9L126.8,67.2c-3.4-2-6.9-3.2-10.9-3.2c-10.9,0-19.8,9-19.8,20H96v344h0.1c0,11,8.9,20,19.8,20  c4.1,0,7.5-1.4,11.2-3.4l278.1-165.5c6.6-5.5,10.8-13.8,10.8-23.1C416,246.7,411.8,238.5,405.2,232.9z" transform="scale(0.035,0.035)" fill="white"></path>
      </svg> Simulate
    </button>
    <div class=ticker-screen>
      <span class="ticker-tag" each={e in commands}>{e}</span>
    </div>
  </div>

  <div class="card card-graph">
    <svg width="100%" height=200 preserveAspectRatio="none" viewBox="0 0 1000 200">
      <g transform="scale(1,1) translate(0,0)">
        <path each={e in graphs} class="svg-stock-graph" fill=none 
          riot-d={e.path} stroke-width={e.thickness} riot-stroke={e.color}></path>
        <path 
          each={e in intervals} riot-stroke={e.color} riot-d={intervalToPath(e)}
          stroke-width={e.thickness} fill=none></path>
      </g>
    </svg>
    <div class="graph-slider">
      <input type=range ref=timeSlider step=1 min=0 max=1000 onchange={reevaluate}>
    </div>
    <div class="stock-widgets">
      <label class=input-pair each={sym in symbols} style={'background: '+sym.color}>
        {sym.name} <input type="number" ref={'symfield_'+sym.name} onchange={onFieldUpdate}>
      </label>
    </div>
  </div>

  <style>
    .card-graph {
      position: relative;
      height: 200px;
    }
    .card-graph svg {
    }
    .svg-graph {
      opacity: 0.85;
    }
    .stock-widgets {
      padding: 10px;
      position: absolute;
      top: 0;
      left: 0;
    }
    .graph-slider {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
    }

    label.input-pair {
      display: inline-block;
      background: #eee;
      padding: 4px 4px 4px 12px;
      box-shadow: 0 0 0 2px white;
      border-radius: 3px;
      font-size: 14px;
      font-family: Avenir, Roboto, sans-serif;
      letter-spacing: 1px;
      margin: 4px;
      color: #FFF;
    }
    label.input-pair input[type=number] {
      appearance: none;
      border: none;
      padding: 4px 8px;
      margin-left: 4px;
      font-size: 14px;
      border-radius: 2px;
      font-family: Avenir, Roboto, sans-serif;
      width: 70px;
    }
    input[type=range] {
      width: 100%;
      background: none;
    }
  </style>
  <script>
    var self = this
    var app = self.opts.app

    const round = (x) => Math.round(x)
    const t2x = t => round(1000-t*1000/app.timeRange)
    const value2y = x => round(200-x)
    const rnd = (low,high) => low + (high-low) * Math.random()
    const flatmap = (list, op) => _.flatten(list.map(op))
    const sum = (list) => list.reduce((a,b) => a+b)
    const average = (list) => list.reduce((a,b) => a+b) / list.length
    const max = (list) => list.reduce((a,b) => Math.max(a,b))
    const min = (list) => list.reduce((a,b) => Math.min(a,b))
    const listSum = (listA,listB) => listA.map((e,i) => listA[i] + listB[i])
    const toPath = (data) => 'M' + data.map((e,i) => t2x(i)+','+value2y(e)).join(' L')

    self.count = function (symbol) {
      return app.env.getHolding(symbol).count
    }

    app.env.onCall = function (func, value, args)Â {
      if (func === 'average') {
        self.intervals.push({
          value: value,
          color: args.stock.color,
          left: app.env.t,
          right: app.env.t+args.days,
          thickness: 3
        })
      }
      if (func === 'historic_average') {
        self.intervals.push({
          value:value,
          color: args.stock.color,
          left:app.env.t+args.offset,
          right:app.env.t+args.days+args.offset,
          thickness: 3
        })
      }
      if (func === 'number' && args.type === 'Sek') {
        self.intervals.push({
          value:value,
          color: 'rgba(0,0,0,0.1)',
          left:0,
          right:1000,
          thickness: 1
        })
      }
    }

    self.onFieldUpdate = function (e) {
      var symbolName = e.item.sym
      app.setHoldingCount(symbolName, e.target.value)
    }

    self.intervalToPath = function (e) {
      return 'M'+t2x(e.left)+','+value2y(e.value)+' L'+t2x(e.right)+','+value2y(e.value)
    }

    self.ast = null
    self.symbols = []
    self.graphs = []
    self.intervals = []
    self.commands = []
    self.t = 0

    self.on('updated', function () {
      self.symbols.forEach(function (sym) {
        self.refs['symfield_'+sym.name].value = self.count(sym.name)
      })
    })

    self.reevaluate = function() {
      if (!self.ast) { return }
      self.intervals = []
      self.commands = []
      self.t = round((1000-self.refs.timeSlider.value) * app.timeRange/1000)
      app.env.t = self.t
      self.ast.funcs.filter(e => !e.params.length).forEach(fn => {
        var res = finscript.evaluate(fn.body, app.env)
        if (res.cmd && res.cmd !== 'noaction') {
          var summary = res.cmd+' '+res.units+' '+res.stock.name+' @ '+round(res.price)+'Sek'
          self.commands.push(summary)
        }
      })
      self.update()
    }
    
    app.events.on('ast-changed', function (ast) {
      self.symbols = []
      self.graphs = []
      self.ast = ast
      finscript.walkTree(ast, function () {}, function (node){
        if (node.node === 'symbol') {
          self.symbols.push(app.env.getSymbol(node.name.substr(1)))
        }
      })
      self.symbols = _.uniq(self.symbols, s => s.name)
      self.symbols.forEach(function (symbol) {
        var path = toPath(symbol.data)
        self.graphs.push({ color: symbol.color, thickness: 1, path: path })
      })

      self.reevaluate()
    })

  </script>
</rule-simulator>
