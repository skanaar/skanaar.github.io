<rule-simulator>

  <div class="card card-padded">
    <label class=input-pair each={sym in symbols}>
      {sym}
      <input type="number" ref={'symfield_'+sym} onchange={onFieldUpdate}>
    </label>
    <div>
      <input type=range step=3 min=0 max=512 onchange={calc}>
    </div>
    <svg width=1000 height=200>
      <g transform="scale(1,1) translate(0,0)">
        <path each={e in graphs}
          riot-d={e.path}
          fill=none riot-stroke={e.color} class="svg-stock-graph"></path>
        <path 
          each={e in intervals} riot-stroke={e.color} riot-d={e.path}
          stroke-width="3" fill=none></path>
      </g>
    </svg>
  </div>

  <style>
    .svg-stock-graph { opacity: 0.5; }

    label.input-pair {
      display: inline-block;
      background: #eee;
      padding: 4px 4px 4px 12px;
      border-radius: 3px;
      font-size: 14px;
      font-family: Avenir, Roboto, sans-serif;
      letter-spacing: 1px;
      margin: 4px;
      color: #666;
    }
    label.input-pair input[type=number] {
      appearance: none;
      border: none;
      padding: 4px 8px;
      margin-left: 4px;
      font-size: 14px;
      border-radius: 2px;
      font-family: Avenir, Roboto, sans-serif;
      width: 70px;
    }
    input[type=range] { width: 100% }
  </style>
  <script>
    var self = this

    var app = self.opts.app
    self.count = function (symbol) {
      return app.env.getHolding(symbol).count
    }

    const clamp = (low, high, x) => Math.max(low, Math.min(high, x))
    const range = (end) => [...Array(end).keys()]
    const rnd = (low,high) => low + (high-low) * Math.random()
    const flatmap = (list, op) => _.flatten(list.map(op))
    const sum = (list) => list.reduce((a,b) => a+b)
    const average = (list) => list.reduce((a,b) => a+b) / list.length
    const max = (list) => list.reduce((a,b) => Math.max(a,b))
    const min = (list) => list.reduce((a,b) => Math.min(a,b))
    const listSum = (listA,listB) => listA.map((e,i) => listA[i] + listB[i])
    const round = (x) => Math.round(x)
    const toPath = (data,dx) => 'M' + data.map((e,i) => 2*(dx+i)+','+round(e)).join(' L')

    function smooth(es){
      return es.map((x,i) => (es[Math.max(0,i-1)] + 4*es[i] + es[Math.min(es.length-1,i+1)])/6)
    }
    function noise(source, amp, level) {
      if (!level) { return source }
      var d = _.flatten(source.map(x => [x+rnd(-amp, amp), x, x+rnd(-amp, amp)]))
      return smooth(noise(d, amp*0.75, level-1))
    }
    const Stock = (name, color, data) => ({ name, color, data })
    var omx = Stock('OMX', '#666', noise([120,120], 60, 5))
    var tobi = Stock('TOBI', '#4F4', listSum(omx.data, noise([0,0], 30, 5)))
    var fing = Stock('FING', '#F44', listSum(omx.data, noise([0,0], 30, 5)))
    var goog = Stock('GOOG', '#44F', listSum(omx.data, noise([0,0], 30, 5)))
    var stocks = { omx, tobi, fing, goog }
    var stockList = [omx, tobi, fing, goog]

    self.graphs = stockList.map(e => ({ color: e.color, path: toPath(e.data, 0) }))
    self.intervals = []

    function applyFunc(id, len, offset, func) {
      var stock = stocks[id]
      var t = Math.min(stock.data.length-len, offset)
      var span = stock.data.slice(t, t+len)
      var y = func(span)
      self.intervals.push({ color: stock.color, path: toPath(span.map(()=>y), t) })
      return y
    }

    self.onFieldUpdate = function (e) {
      var symbolName = e.item.sym
      app.setHoldingCount(symbolName, e.target.value)
    }

    self.symbols = []

    self.on('updated', function () {
      self.symbols.forEach(sym => self.refs['symfield_'+sym].value = self.count(sym))
    })
    
    app.events.on('ast-changed', function (ast) {
      self.symbols = []
      finscript.walkTree(ast, function () {}, function (node){
        if (node.node === 'symbol') {
          self.symbols.push(node.name.substr(1))
        }
      })
      self.symbols = _.uniq(self.symbols)
      ast.funcs.filter(e => !e.params.length).forEach(fn => {
        try {
          var res = finscript.evaluate(fn.body, app.env)
          if (res.cmd) {
            res = res.cmd+' '+res.units+'*'+res.stock.name+' @ '+res.price
          }
          console.log(fn.name + '() ' + res)
        } catch (e) {
          console.log(fn.name + '() ' + e.message)
        }
      })
      self.update()
    })

  </script>
</rule-simulator>
